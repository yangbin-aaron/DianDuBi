package cn.com.cunw.diandubiapp.base.popup;import android.app.Activity;import android.content.Context;import android.graphics.Color;import android.graphics.drawable.ColorDrawable;import android.graphics.drawable.Drawable;import android.os.Build;import android.support.annotation.ColorInt;import android.support.annotation.IdRes;import android.support.annotation.NonNull;import android.support.annotation.RequiresApi;import android.support.v4.widget.PopupWindowCompat;import android.util.Log;import android.view.Gravity;import android.view.KeyEvent;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.view.ViewGroupOverlay;import android.widget.PopupWindow;import java.lang.reflect.Field;/** * @author LiuJianjun * @time 2018-09-19 11:07 * <p> * 功能： */public class BasePopupWindow implements PopupWindow.OnDismissListener {    private static final String TAG = "BasePopupWindow";    private PopupWindow mPopupWindow = null;    protected Context mContext;    private int mDimColor;    private int mDimAlpha;    private ViewGroup mBackgroundView;    private boolean mBackgroundDim;    private boolean isShowing;    private int mWidth, mHeight;    private DismissListener dismissListener;    /**     * BasePopupWindow 构造器     *     * @param context          上下文     * @param contentView      内容view     * @param width            宽     * @param height           高     * @param animationStyle   动画style     * @param dimColor         变暗颜色     * @param dimAlpha         变暗透明度     * @param backgroundView   背景view     * @param outSideTouchable 点击外围是否dismiss     * @param backgroundDim    背景是否变暗     */    public BasePopupWindow(Context context, View contentView, int width, int height, int animationStyle, @ColorInt int dimColor, int dimAlpha,                           ViewGroup backgroundView, boolean outSideTouchable, boolean backgroundDim) {        mContext = context;        this.mWidth = width;        this.mHeight = height;        mPopupWindow = new PopupWindow(contentView, width, height);//        fitPopupWindowOverStatusBar(true);        mPopupWindow.setClippingEnabled(false);        initOutSideTouchable(outSideTouchable);        mPopupWindow.setOnDismissListener(this);        if (animationStyle != 0) {            mPopupWindow.setAnimationStyle(animationStyle);        }        mDimColor = dimColor;        mDimAlpha = dimAlpha;        mBackgroundView = backgroundView;        mBackgroundDim = backgroundDim;    }    public boolean isShowing() {        return isShowing;    }    @Override    public void onDismiss() {        isShowing = false;        handleDismissed();        if (dismissListener != null) {            dismissListener.onDismiss();        }    }    public void setDismissListener(DismissListener dismissListener) {        this.dismissListener = dismissListener;    }    /**     * 获取popupWindow内容view     *     * @return     */    public View getContentView() {        if (mPopupWindow != null) {            return mPopupWindow.getContentView();        } else {            return null;        }    }    /**     * 根据viewId获取相应的view     *     * @param viewId     * @param <T>     * @return     */    public <T extends View> T getView(@IdRes int viewId) {        View view = null;        if (getContentView() != null) {            view = getContentView().findViewById(viewId);        }        return (T) view;    }    public void dismiss() {        if (mPopupWindow != null) {            mPopupWindow.dismiss();        }    }    public void fitPopupWindowOverStatusBar(boolean needFullScreen) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {            try {                Field mLayoutInScreen = PopupWindow.class.getDeclaredField("mLayoutInScreen");                mLayoutInScreen.setAccessible(true);                mLayoutInScreen.set(mPopupWindow, needFullScreen);            } catch (NoSuchFieldException e) {                e.printStackTrace();            } catch (IllegalAccessException e) {                e.printStackTrace();            }        }    }    /**     * 下拉显示     *     * @param anchor 锚点view     */    public void showAsDropDown(View anchor) {        this.showAsDropDown(anchor, 0, 0);    }    /**     * 下拉显示     *     * @param anchor  锚点view     * @param xOffset 水平方向偏移量     * @param yOffset 垂直方向偏移量     */    public void showAsDropDown(View anchor, int xOffset, int yOffset) {        final int defGravity = Gravity.TOP | Gravity.START;        this.showAsDropDown(anchor, xOffset, yOffset, defGravity);    }    /**     * 下拉显示     *     * @param anchor  锚点view     * @param xOffset 水平方向偏移量     * @param yOffset 垂直方向偏移量     * @param gravity     */    public void showAsDropDown(View anchor, int xOffset, int yOffset, int gravity) {        if (mPopupWindow != null) {            isShowing = true;            handleBackgroundDim();            mPopupWindow.showAsDropDown(anchor, xOffset, yOffset, gravity);        }    }    /**     * @param parent     * @param gravity     * @param x     * @param y     */    public void showAtLocation(View parent, int gravity, int x, int y) {        if (mPopupWindow != null) {            isShowing = true;            handleBackgroundDim();            mPopupWindow.showAtLocation(parent, gravity, x, y);        }    }    /**     * 相对anchor view显示，适用 宽高不为match_parent     * <p>     * 注意：如果使用 VerticalGravity 和 HorizontalGravity 时，请确保使用之后 PopupWindow 没有超出屏幕边界，     * 如果超出屏幕边界，VerticalGravity 和 HorizontalGravity 可能无效，从而达不到你想要的效果。     *     *     * @param anchor     * @param verticalGravity     * @param horizontalGravity     */    public void showAtAnchorView(@NonNull View anchor, @VerticalGravity int verticalGravity, @HorizontalGravity int horizontalGravity) {        showAtAnchorView(anchor, verticalGravity, horizontalGravity, 0, 0);    }    /**     * 相对anchor view显示，适用 宽高不为match_parent     * <p>     * 注意：如果使用 VerticalGravity 和 HorizontalGravity 时，请确保使用之后 PopupWindow 没有超出屏幕边界，     * 如果超出屏幕边界，VerticalGravity 和 HorizontalGravity 可能无效，从而达不到你想要的效果。     *     * @param anchor     * @param verticalGravity   垂直方向的对齐方式     * @param horizontalGravity 水平方向的对齐方式     * @param x                 水平方向的偏移     * @param y                 垂直方向的偏移     */    public void showAtAnchorView(@NonNull View anchor, @VerticalGravity final int verticalGravity, @HorizontalGravity final int horizontalGravity, int x, int y) {        if (mPopupWindow == null) {            return;        }        isShowing = true;        View contentView = getContentView();        contentView.measure(0, View.MeasureSpec.UNSPECIFIED);        final int measuredW = contentView.getMeasuredWidth();        final int measuredH = contentView.getMeasuredHeight();        x = calculateX(anchor, horizontalGravity, measuredW, x);        y = calculateY(anchor, verticalGravity, measuredH, y);        handleBackgroundDim();        PopupWindowCompat.showAsDropDown(mPopupWindow, anchor, x, y, Gravity.NO_GRAVITY);    }    /**     * 初始化外部点击事件     *     * @param outSideTouchable     */    private void initOutSideTouchable(final boolean outSideTouchable) {        if (!outSideTouchable) {            //from https://github.com/pinguo-zhouwei/CustomPopwindow            mPopupWindow.setFocusable(true);            mPopupWindow.setOutsideTouchable(false);            mPopupWindow.setBackgroundDrawable(null);            //注意下面这三个是contentView 不是PopupWindow，响应返回按钮事件            mPopupWindow.getContentView().setFocusable(true);            mPopupWindow.getContentView().setFocusableInTouchMode(true);            mPopupWindow.getContentView().setOnKeyListener(new View.OnKeyListener() {                @Override                public boolean onKey(View v, int keyCode, KeyEvent event) {                    if (keyCode == KeyEvent.KEYCODE_BACK) {                        mPopupWindow.dismiss();                        return true;                    }                    return false;                }            });            //在Android 6.0以上 ，只能通过拦截事件来解决            mPopupWindow.setTouchInterceptor(new View.OnTouchListener() {                @Override                public boolean onTouch(View v, MotionEvent event) {                    final int x = (int) event.getX();                    final int y = (int) event.getY();                    if ((event.getAction() == MotionEvent.ACTION_DOWN)                            && ((x < 0) || (x >= mWidth && mWidth != -2) || (y < 0) || (y >= mHeight && mHeight != -2))) {                        //outside                        Log.d(TAG, "onTouch outside:mWidth=" + mWidth + ",mHeight=" + mHeight);                        return true;                    } else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) {                        //outside                        Log.d(TAG, "onTouch outside event:mWidth=" + mWidth + ",mHeight=" + mHeight);                        return true;                    }                    return false;                }            });        } else {            mPopupWindow.setFocusable(true);            mPopupWindow.setOutsideTouchable(outSideTouchable);            mPopupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));        }    }    /**     * 根据垂直gravity计算y偏移     *     * @param anchor     * @param verticalGravity     * @param measuredHeight     * @param y     * @return     */    private int calculateY(View anchor, int verticalGravity, int measuredHeight, int y) {        switch (verticalGravity) {            case VerticalGravity.ABOVE:                //anchor view之上                y -= measuredHeight + anchor.getHeight();                break;            case VerticalGravity.ALIGN_BOTTOM:                //anchor view底部对齐                y -= measuredHeight;                break;            case VerticalGravity.CENTER:                //anchor view垂直居中                y -= anchor.getHeight() / 2 + measuredHeight / 2;                break;            case VerticalGravity.ALIGN_TOP:                //anchor view顶部对齐                y -= anchor.getHeight();                break;            case VerticalGravity.BELOW:                //anchor view之下                // Default position.                break;        }        return y;    }    /**     * 根据水平gravity计算x偏移     *     * @param anchor     * @param horizontalGravity     * @param measuredWidth     * @param x     * @return     */    private int calculateX(View anchor, int horizontalGravity, int measuredWidth, int x) {        switch (horizontalGravity) {            case HorizontalGravity.LEFT:                //anchor view左侧                x -= measuredWidth;                break;            case HorizontalGravity.ALIGN_RIGHT:                //与anchor view右边对齐                x -= measuredWidth - anchor.getWidth();                break;            case HorizontalGravity.CENTER:                //anchor view水平居中                x += anchor.getWidth() / 2 - measuredWidth / 2;                break;            case HorizontalGravity.ALIGN_LEFT:                //与anchor view左边对齐                // Default position.                break;            case HorizontalGravity.RIGHT:                //anchor view右侧                x += anchor.getWidth();                break;        }        return x;    }    /**     * 弹出时处理背景变暗     */    private void handleBackgroundDim() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {            if (mBackgroundDim) {                if (mBackgroundView != null) {                    applyDim(mBackgroundView);                } else if (getContentView() != null) {                    Activity activity = (Activity) getContentView().getContext();                    if (activity != null) {                        applyDim(activity);                    }                }            }        }    }    private void applyDim(Activity activity) {        ViewGroup parent = (ViewGroup) activity.getWindow().getDecorView().getRootView();        applyDim(parent);    }    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)    private void applyDim(ViewGroup dimView) {        ViewGroup parent = dimView;        Drawable dim = new ColorDrawable(mDimColor);        dim.setBounds(0, 0, parent.getWidth(), parent.getHeight());        dim.setAlpha(mDimAlpha);        ViewGroupOverlay overlay = parent.getOverlay();        overlay.add(dim);    }    /**     * PopupWindow消失后处理一些逻辑     */    private void handleDismissed() {        clearBackgroundDim();    }    private void clearBackgroundDim() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {            if (mBackgroundDim) {                if (mBackgroundView != null) {                    clearDim(mBackgroundView);                } else if (getContentView() != null) {                    Activity activity = (Activity) getContentView().getContext();                    if (activity != null) {                        clearDim(activity);                    }                }            }        }    }    private void clearDim(Activity activity) {        ViewGroup parent = (ViewGroup) activity.getWindow().getDecorView().getRootView();        clearDim(parent);    }    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)    private void clearDim(ViewGroup dimView) {        ViewGroup parent = dimView;        ViewGroupOverlay overlay = parent.getOverlay();        overlay.clear();    }    public interface DismissListener {        void onDismiss();    }    public static class Builder extends BaseBuilder {        public Builder(Context context) {            super(context);        }        @Override        public BasePopupWindow build() {            return new BasePopupWindow(mContext, mContentView, mWidth, mHeight, mAnimationStyle, mDimColor, mDimAlpha, mBackgroundView, mOutsideTouchable, mBackgroundDim);        }    }}